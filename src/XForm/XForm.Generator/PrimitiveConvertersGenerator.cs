// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.IO;

namespace XForm.Generator
{
    public class PrimitiveConvertersGenerator
    {
        public const string FilePrefix = @"// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;

using XForm.Data;

// GENERATED by XForm.Generator\PrimitiveConvertersGenerator.cs

namespace XForm.Types
{";

        public const string FileSuffix = @"
}";

        public const string ClassPrefix = @"

    /// <summary>
    ///  Converter from numeric types to long. [GENERATED]
    /// </summary>
    internal class LongConverter : INumericConverter
    {
        private long _defaultValue;
        private long[] _array;
        private bool[] _couldNotConvert;

        public LongConverter(object defaultValue)
        {
            _defaultValue = (long)(TypeConverterFactory.ConvertSingle(defaultValue, typeof(long)) ?? default(long));
        }";

        public const string ClassSuffix = @"
    }";

        public const string SafeConversion = @"

        public bool[] FromFromType(XArray xarray, out Array result)
        {
            Allocator.AllocateToSize(ref _array, (xarray.Selector.IsSingleValue ? 1 : xarray.Count));

            fromType[] sourceArray = (fromType[])xarray.Array;
            if (xarray.Selector.Indices != null)
            {
                for (int i = 0; i < xarray.Count; ++i)
                {
                    _array[i] = (toType)sourceArray[xarray.Index(i)];
                }
            }
            else if (!xarray.Selector.IsSingleValue)
            {
                int offset = xarray.Selector.StartIndexInclusive;
                for (int i = 0; i < xarray.Count; ++i)
                {
                    _array[i] = (toType)sourceArray[i + offset];
                }
            }
            else
            {
                _array[0] = (toType)sourceArray[0];
            }

            result = _array;
            return null;
        }";

        public const string CheckingConversion = @"

        public bool[] FromFromType(XArray xarray, out Array result)
        {
            Allocator.AllocateToSize(ref _array, (xarray.Selector.IsSingleValue ? 1 : xarray.Count));
            Allocator.AllocateToSize(ref _couldNotConvert, (xarray.Selector.IsSingleValue ? 1 : xarray.Count));

            bool couldNotConvertAny = false;
            fromType[] sourceArray = (fromType[])xarray.Array;
            if (xarray.Selector.Indices != null)
            {
                for (int i = 0; i < xarray.Count; ++i)
                {
                    fromType value = sourceArray[xarray.Index(i)];
                    bool outOfRange = value < (fromType)toType.MinValue || value > (fromType)toType.MaxValue;

                    _array[i] = (outOfRange ? _defaultValue : (toType)value);
                    _couldNotConvert[i] = outOfRange;
                    couldNotConvertAny |= outOfRange;
                }
            }
            else if (!xarray.Selector.IsSingleValue)
            {
                int offset = xarray.Selector.StartIndexInclusive;
                for (int i = 0; i < xarray.Count; ++i)
                {
                    fromType value = sourceArray[i + offset];
                    bool outOfRange = value < (fromType)toType.MinValue || value > (fromType)toType.MaxValue;

                    _array[i] = (outOfRange ? _defaultValue : (toType)value);
                    _couldNotConvert[i] = outOfRange;
                    couldNotConvertAny |= outOfRange;
                }
            }
            else
            {
                fromType value = sourceArray[0];
                bool outOfRange = value < (fromType)toType.MinValue || value > (fromType)toType.MaxValue;
                _array[0] = (outOfRange ? _defaultValue : (toType)value);
                _couldNotConvert[0] = outOfRange;
                couldNotConvertAny = outOfRange;
            }

            result = _array;
            return (couldNotConvertAny ? _couldNotConvert : null);
        }";

        public static void Generate(string outputPath)
        {
            using (var writer = new StreamWriter(File.Open(outputPath, FileMode.Create)))
            {
                writer.Write(FilePrefix);

                WriteLinePerType(writer, @"
    internal interface INumericConverter
    {", @"
        bool[] FromTypeName(XArray xarray, out Array result);",
        @"
    }
");

                writer.Write(@"
    internal static class PrimitiveConverterFactory
    {");

                WriteLinePerType(writer, @"
        public static NegatedTryConvert TryGetNegatedTryConvert(Type fromType, Type toType, object defaultValue)
        {", @"
            if (toType == typeof(typeName)) return TryGetNegatedTryConvert(fromType, new TypeNameConverter(defaultValue));", @"
            return null;
        }
");
                WriteLinePerType(writer, @"
        public static NegatedTryConvert TryGetNegatedTryConvert(Type fromType, INumericConverter converter)
        {", @"
            if (fromType == typeof(typeName)) return converter.FromTypeName;", @"
            return null;
        }
    }");

                for (int i = 0; i < SupportedTypes.SignedNumbersInOrder.Length; ++i)
                {
                    WriteSignedClass(writer, SupportedTypes.SignedNumbersInOrder[i], i);
                }

                for (int i = 0; i < SupportedTypes.UnsignedNumbersInOrder.Length; ++i)
                {
                    WriteUnsignedClass(writer, SupportedTypes.UnsignedNumbersInOrder[i], i);
                }

                for (int i = 0; i < SupportedTypes.FloatingPointInOrder.Length; ++i)
                {
                    WriteFloatClass(writer, SupportedTypes.FloatingPointInOrder[i], i);
                }

                writer.Write(FileSuffix);
            }
        }

        private static void WriteLinePerType(StreamWriter writer, string prefix, string lineTemplate, string suffix)
        {
            writer.Write(prefix);

            foreach (string typeName in SupportedTypes.PrimitiveTypes)
            {
                writer.Write(lineTemplate.Replace("typeName", typeName).Replace("TypeName", SupportedTypes.ToClassName(typeName)));
            }

            writer.Write(suffix);
        }

        private static void WriteSignedClass(StreamWriter writer, string typeName, int index)
        {
            string className = SupportedTypes.ToClassName(typeName);

            writer.Write(ClassPrefix
                .Replace("long", typeName)
                .Replace("Long", className));

            // Smaller signed types are safe
            for (int i = 0; i < SupportedTypes.SignedNumbersInOrder.Length; ++i)
            {
                WriteConversion(writer, typeName, SupportedTypes.SignedNumbersInOrder[i], i <= index);
            }

            // Smaller unsigned types are safe
            for (int i = 0; i < SupportedTypes.UnsignedNumbersInOrder.Length; ++i)
            {
                WriteConversion(writer, typeName, SupportedTypes.UnsignedNumbersInOrder[i], i < index, false);
            }

            // All float conversions are unsafe
            for (int i = 0; i < SupportedTypes.FloatingPointInOrder.Length; ++i)
            {
                WriteConversion(writer, typeName, SupportedTypes.FloatingPointInOrder[i], false);
            }

            writer.Write(ClassSuffix);
        }

        private static void WriteUnsignedClass(StreamWriter writer, string typeName, int index)
        {
            string className = SupportedTypes.ToClassName(typeName);

            writer.Write(ClassPrefix
                .Replace("long", typeName)
                .Replace("Long", className));

            // All signed types are unsafe
            for (int i = 0; i < SupportedTypes.SignedNumbersInOrder.Length; ++i)
            {
                WriteConversion(writer, typeName, SupportedTypes.SignedNumbersInOrder[i], false, true, i > index);
            }

            // Smaller unsigned types are safe
            for (int i = 0; i < SupportedTypes.UnsignedNumbersInOrder.Length; ++i)
            {
                WriteConversion(writer, typeName, SupportedTypes.UnsignedNumbersInOrder[i], i <= index, false, i > index);
            }

            // All float conversions are unsafe
            for (int i = 0; i < SupportedTypes.FloatingPointInOrder.Length; ++i)
            {
                WriteConversion(writer, typeName, SupportedTypes.FloatingPointInOrder[i], false);
            }

            writer.Write(ClassSuffix);
        }

        private static void WriteFloatClass(StreamWriter writer, string typeName, int index)
        {
            string className = SupportedTypes.ToClassName(typeName);

            string prefix = ClassPrefix
                .Replace("long", typeName)
                .Replace("Long", className);

            if (typeName == "double") prefix = prefix.Replace("\r\n        private bool[] _couldNotConvert;", "");
            writer.Write(prefix);

            // All signed types are safe
            for (int i = 0; i < SupportedTypes.SignedNumbersInOrder.Length; ++i)
            {
                WriteConversion(writer, typeName, SupportedTypes.SignedNumbersInOrder[i], true);
            }

            // All unsigned types are safe
            for (int i = 0; i < SupportedTypes.UnsignedNumbersInOrder.Length; ++i)
            {
                WriteConversion(writer, typeName, SupportedTypes.UnsignedNumbersInOrder[i], true);
            }

            // Smaller float conversions are safe
            for (int i = 0; i < SupportedTypes.FloatingPointInOrder.Length; ++i)
            {
                WriteConversion(writer, typeName, SupportedTypes.FloatingPointInOrder[i], i <= index);
            }

            writer.Write(ClassSuffix);
        }

        private static void WriteConversion(StreamWriter writer, string toType, string fromType, bool isSafe, bool checkLowerBound = true, bool checkUpperBound = true)
        {
            if (isSafe)
            {
                WriteConversion(writer, SafeConversion, toType, fromType);
            }
            else
            {
                WriteConversion(writer, CheckingConversion, toType, fromType, checkLowerBound, checkUpperBound);
            }
        }

        private static void WriteConversion(StreamWriter writer, string template, string toType, string fromType, bool checkLowerBound = true, bool checkUpperBound = true)
        {
            if (!checkLowerBound) template = template.Replace("value < (fromType)toType.MinValue || ", "");
            if (!checkUpperBound) template = template.Replace(" || value > (fromType)toType.MaxValue", "");

            template = template
                .Replace("toType", toType)
                .Replace("fromType", fromType)
                .Replace("FromType", SupportedTypes.ToClassName(fromType));

            writer.Write(template);
        }
    }
}
